////  PlayerDemoViewController.m//  PlayerDemo////  Created by apple on 11-4-2.//  Copyright __MyCompanyName__ 2011. All rights reserved.//#import "PlayerDemoViewController.h"#import "hcnetsdk.h"#import "HikDec.h"#import "OtherTest.h"#import "VoiceTalk.h"#import "Preview.h"#import "EzvizTrans.h"#import <Foundation/Foundation.h>#include <stdio.h>#include <ifaddrs.h>#include <sys/socket.h>#include <sys/poll.h>#include <net/if.h>#include <map>#import "FindFileViewController.h"@implementation PlayerDemoViewController@synthesize	m_deviceIpField;@synthesize	m_devicePortField;@synthesize	m_uerNameField;@synthesize	m_passwordField;@synthesize m_playView;@synthesize m_playButton;@synthesize m_playbackButton;@synthesize m_loginButton;@synthesize m_getcfgButton;@synthesize m_captureButton;@synthesize m_recordButton;@synthesize m_talkButton;@synthesize m_ptzButton;@synthesize m_otherButton;@synthesize m_nPreviewPort;@synthesize m_nPlaybackPort;@synthesize m_fp;@synthesize m_playThreadID;@synthesize m_bThreadRun;@synthesize m_lUserID;@synthesize m_lRealPlayID;@synthesize m_lPlaybackID;@synthesize m_bPreview;@synthesize m_bRecord;@synthesize m_bPTZL;@synthesize m_bVoiceTalk;@synthesize m_bStopPlayback;PlayerDemoViewController *g_pController = NULL;int g_iStartChan = 0;int g_iPreviewChanNum = 0;bool g_bDecode = true;//playback callback functionvoid fPlayDataCallBack_V40(LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,void *pUser){      PlayerDemoViewController *pDemo = (PlayerDemoViewController*)pUser;	int i = 0;    switch (dwDataType)    {        case NET_DVR_SYSHEAD:                        if (dwBufSize > 0 && pDemo->m_nPlaybackPort == -1)            {                if(PlayM4_GetPort(&pDemo->m_nPlaybackPort) != 1)                {                    NSLog(@"PlayM4_GetPort failed:%d",  NET_DVR_GetLastError());                    break;                }                if (!PlayM4_SetStreamOpenMode(pDemo->m_nPlaybackPort, STREAME_FILE))                {                    break;                }                if (!PlayM4_OpenStream(pDemo->m_nPlaybackPort, pBuffer , dwBufSize, 2*1024*1024))                {                    break;                }                pDemo->m_bPreview = 0;                [pDemo startPlayer];            }            break;        default:            if (dwBufSize > 0 && pDemo->m_nPlaybackPort != -1 && !pDemo->m_bStopPlayback)            {                for(i = 0; i < 4000; i++)                {                    if(PlayM4_InputData(pDemo->m_nPlaybackPort, pBuffer, dwBufSize))                    {                        break;                    }                      usleep(10*1000);                }            }            break;    }	}void g_fExceptionCallBack(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser){    NSLog(@"g_fExceptionCallBack Type[0x%x], UserID[%d], Handle[%d]", dwType, lUserID, lHandle);}//other function button click up-(IBAction)otherBtnClicked:(id)sender{    //解析服务器获取设备ip地址//    Test_HikOnline();        //获取或设置channel 名称//    Test_PicCfg_V30(m_lUserID, g_iStartChan);        //查找设备中存储的视频文件//    Test_FindFiles(m_lUserID, g_iStartChan);    //    TEST_Manage(m_lUserID, g_iStartChan);//    TEST_PTZ(m_lRealPlayID, m_lUserID, g_iStartChan);//    TEST_Config(m_lRealPlayID, m_lUserID, g_iStartChan);//    TEST_Other(m_lRealPlayID, m_lUserID, g_iStartChan, m_lPlaybackID);//    TEST_Alarm(m_lUserID);}//ptz button click up-(IBAction)ptzBtnClickedUp:(id)sender{    NSLog(@"ptzBtnClickedUp");    if (m_bPTZL == true) {        if(!NET_DVR_PTZControl_Other(m_lUserID, g_iStartChan, PAN_LEFT, 1))        {            NSLog(@"stop PAN_LEFT failed with[%d]", NET_DVR_GetLastError());        }        else        {            NSLog(@"stop PAN_LEFT succ");        }        [m_ptzButton setTitle:@"PTZ(R)" forState:UIControlStateNormal];    }    else    {        if(!NET_DVR_PTZControl_Other(m_lUserID, g_iStartChan, PAN_RIGHT, 1))        {            NSLog(@"stop PAN_RIGHT failed with[%d]", NET_DVR_GetLastError());        }        else        {            NSLog(@"stop PAN_RIGHT succ");        }        [m_ptzButton setTitle:@"PTZ(L)" forState:UIControlStateNormal];    }}//ptz button click-(IBAction)ptzBtnClicked:(id)sender{        NSLog(@"ptzBtnClicked");    if (m_lUserID < 0) {        NSLog(@"Please logon a device first!");        return;    }    if (m_bPTZL == false)    {        if(!NET_DVR_PTZControl_Other(m_lUserID, g_iStartChan, PAN_LEFT, 0))        {            NSLog(@"start PAN_LEFT failed with[%d]", NET_DVR_GetLastError());        }        else        {            NSLog(@"start PAN_LEFT succ");        }        m_bPTZL = true;    }    else    {        if(!NET_DVR_PTZControl_Other(m_lUserID, g_iStartChan, PAN_RIGHT, 0))        {            NSLog(@"start PAN_RIGHT failed with[%d]", NET_DVR_GetLastError());        }        else        {            NSLog(@"start PAN_RIGHT succ");        }        m_bPTZL = false;    }}//talk button click-(IBAction)talkBtnClicked:(id)sender{    NSLog(@"talkBtnClicked");    #if !TARGET_IPHONE_SIMULATOR    if(!m_bVoiceTalk)    {        if(startVoiceTalk(m_lUserID) >= 0)        {            m_bVoiceTalk = true;        }    }    else    {        stopVoiceTalk();        m_bVoiceTalk = false;    }#endif}// record button click while realplay-(IBAction)recordBtnClicked:(id)sender{    NSLog(@"recordBtnClicked");    if (m_bRecord == false)    {        if (m_lRealPlayID < 0) {            NSLog(@"Please start realplay first!");            return;        }                NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);        NSString *documentsDirectory = [paths objectAtIndex:0];        char szFileName[256] = {0};        NSString* date;        NSDateFormatter* formatter = [[NSDateFormatter alloc]init];        [formatter setDateFormat:@"YYYY-MM-dd-hh-mm-ss"];        date = [formatter stringFromDate:[NSDate date]];                sprintf(szFileName, "%s/%s.mp4", (char*)documentsDirectory.UTF8String, (char*)date.UTF8String);        if (!NET_DVR_SaveRealData(m_lRealPlayID, szFileName)) {            NSLog(@"NET_DVR_SaveRealData failed with[%d]", NET_DVR_GetLastError());            return;        }        NSLog(@"NET_DVR_SaveRealData succ [%s]", szFileName);                m_bRecord = true;        [m_recordButton setTitle:@"Stop Record" forState:UIControlStateNormal];    }    else    {        NET_DVR_StopSaveRealData(m_lRealPlayID);        m_bRecord = false;        [m_recordButton setTitle:@"Start Record" forState:UIControlStateNormal];    }}// capture button click-(IBAction)captureBtnClicked:(id)sender{    NSLog(@"captureBtnClicked");    if (m_lRealPlayID < 0) {        NSLog(@"Please start realplay first!");        return;    }    int nHeight = 0;    int nWidth = 0;    if (!PlayM4_GetPictureSize(m_nPreviewPort, &nWidth, &nHeight)){        NSLog(@"PlayM4_GetPictureSize fialed with[%d]", PlayM4_GetLastError(m_nPreviewPort));        return;    }    //2cif -> 4cif    if (nWidth == 704 && (nHeight == 288 || nHeight == 240)) {        nHeight <<= 1;    }        int nSize = 5 * nWidth * nHeight;    char *pBuf = new char[nSize];    memset(pBuf, 0, nSize);    unsigned int  dwRet = 0;    if (!PlayM4_GetBMP(m_nPreviewPort, (unsigned char*)pBuf, nSize, &dwRet))    {        delete []pBuf;        pBuf = NULL;        NSLog(@"PlayM4_GetBMP failed with[%d]", PlayM4_GetLastError(m_nPreviewPort));        return;    }        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);    NSString *documentsDirectory = [paths objectAtIndex:0];    char szFileName[256] = {0};    NSString* date;    NSDateFormatter* formatter = [[NSDateFormatter alloc]init];    [formatter setDateFormat:@"YYYY-MM-dd hh:mm:ss"];    date = [formatter stringFromDate:[NSDate date]];        sprintf(szFileName, "%s/%s.bmp", (char*)documentsDirectory.UTF8String, (char*)date.UTF8String);        FILE *pFile = NULL;    pFile = fopen(szFileName, "wb");    fwrite(pBuf, dwRet, 1, pFile);    fclose(pFile);        delete []pBuf;    pBuf = NULL;        NSLog(@"capture bmp succ[%s]", szFileName);    return;}// preview button Click-(IBAction) playerBtnClicked:(id)sender{	NSLog(@"liveStreamBtnClicked");	    if(g_iPreviewChanNum > 1)    {        if(!m_bPreview)        {            int iPreviewID[MAX_VIEW_NUM] = {0};            for(int i = 0; i < MAX_VIEW_NUM; i++)            {                iPreviewID[i] = startPreview(m_lUserID, g_iStartChan, m_multiView[i], i);            }            m_lRealPlayID = iPreviewID[0];            m_bPreview = true;            [m_playButton setTitle:@"Stop Preview" forState:UIControlStateNormal];        }        else        {            for(int i = 0; i < MAX_VIEW_NUM; i++)            {                stopPreview(i);            }            m_bPreview = false;            [m_playButton setTitle:@"Start Preview" forState:UIControlStateNormal];        }    }    else    {        if(!m_bPreview)        {            m_lRealPlayID = startPreview(m_lUserID, g_iStartChan, m_playView, 0);            if(m_lRealPlayID >= 0)            {                m_bPreview = true;                [m_playButton setTitle:@"Stop Preview" forState:UIControlStateNormal];            }        }        else        {            stopPreview(0);            m_bPreview = false;            [m_playButton setTitle:@"Start Preview" forState:UIControlStateNormal];        }    }}//config button click-(IBAction) getcfgBtnClicked:(id)sender{	NSLog(@"getcfgBtnClicked");        if(m_lUserID == -1)    {        NSLog(@"Please logon a device first!");        return;    }       	    NET_DVR_COMPRESSIONCFG_V30 struCompress = {0};    DWORD dwRet = 0;    if (!NET_DVR_GetDVRConfig(m_lUserID, NET_DVR_GET_COMPRESSCFG_V30, g_iStartChan, &struCompress, sizeof(struCompress), &dwRet))    {        NSLog(@"NET_DVR_GET_COMPRESSCFG_V30 failed with[%d]", NET_DVR_GetLastError());    }    else    {        NSLog(@"NET_DVR_GET_COMPRESSCFG_V30 succ");    }    //set substream resolution to cif    struCompress.struNetPara.byResolution = 1;    if (!NET_DVR_SetDVRConfig(m_lUserID, NET_DVR_SET_COMPRESSCFG_V30, g_iStartChan, &struCompress, sizeof(struCompress)))    {        NSLog(@"NET_DVR_SET_COMPRESSCFG_V30 failed with[%d]", NET_DVR_GetLastError());    }    else    {        NSLog(@"NET_DVR_SET_COMPRESSCFG_V30 succ");    }}//start player- (void) startPlayer{	[self performSelectorOnMainThread:@selector(playerPlay) 						   withObject:nil						waitUntilDone:NO];}//play,the function PlayM4_Play must be called in main thread- (void) playerPlay{    int nRet = 0;    if(m_bPreview)    {        nRet = PlayM4_Play(m_nPreviewPort, m_playView);        PlayM4_PlaySound(m_nPreviewPort);    }    else    {        nRet = PlayM4_Play(m_nPlaybackPort, m_playView);        PlayM4_PlaySound(m_nPlaybackPort);    }       	if (nRet != 1)	{		NSLog(@"PlayM4_Play fail");		[self stopPlay];		return;	}}- (void)previewPlay:(int*)iPlayPort playView:(UIView*)playView{    m_nPreviewPort = *iPlayPort;    int iRet = PlayM4_Play(*iPlayPort, playView);    PlayM4_PlaySound(*iPlayPort);    if (iRet != 1)    {        NSLog(@"PlayM4_Play fail");        [self stopPreviewPlay];        return;    }}- (void)stopPreviewPlay:(int*)iPlayPort{    PlayM4_StopSound();    if (!PlayM4_Stop(*iPlayPort))    {        NSLog(@"PlayM4_Stop failed");    }    if(!PlayM4_CloseStream(*iPlayPort))    {        NSLog(@"PlayM4_CloseStream failed");    }    if (!PlayM4_FreePort(*iPlayPort))    {        NSLog(@"PlayM4_FreePort failed");    }    *iPlayPort = -1;}// playback button click (bytime)-(IBAction) playbackBtnClicked:(id)sender{	NSLog(@"playbackBtnClicked");       if (m_lPlaybackID == -1)       {           if(m_lUserID == -1)           {               NSLog(@"Please login on the device first!");               return;           }                                 NET_DVR_TIME struStartTime = {0};           NET_DVR_TIME struEndTime = {0};           struStartTime.dwYear = 2015;           struStartTime.dwMonth = 1;           struStartTime.dwDay = 18;                      struEndTime.dwYear = 2016;           struEndTime.dwMonth = 12;           struEndTime.dwDay = 23;           NSLog(@"channel = %d",g_iStartChan);           m_lPlaybackID = NET_DVR_PlayBackByTime(m_lUserID, g_iStartChan, &struStartTime, &struEndTime, NULL);           if (m_lPlaybackID == -1)            {               NSLog(@"NET_DVR_PlayBackByTime failed:%d",  NET_DVR_GetLastError());               UIAlertView *alert = [[UIAlertView alloc]                                      initWithTitle:kWarningTitle                                     message:kRealPlayFailMsg                                     delegate:nil                                      cancelButtonTitle:kWarningConfirmButton                                     otherButtonTitles:nil];	               [alert show];               [alert release];                                      [self stopPlayback];               return;           }                      if (!NET_DVR_SetPlayDataCallBack_V40(m_lPlaybackID, fPlayDataCallBack_V40 , self))           {               NSLog(@"NET_DVR_SetPlayDataCallBack_V40 failed:%d",  NET_DVR_GetLastError());               [self stopPlayback];               return;           }                      if (!NET_DVR_PlayBackControl_V40(m_lPlaybackID, NET_DVR_PLAYSTART, NULL, 0, NULL, NULL))           {               NSLog(@"NET_DVR_PlayBackControl_V40 failed:%d",  NET_DVR_GetLastError());               [self stopPlayback];               return;           }           m_bStopPlayback = false;           [m_playbackButton setTitle:@"Stop Playback" forState:UIControlStateNormal];       }       else       {           m_bStopPlayback = true;            [self stopPlayback];            [m_playbackButton setTitle:@"Start Playback" forState:UIControlStateNormal];       }}/* // playback button click (by Name)-(IBAction) playbackBtnClicked:(id)sender{    NSLog(@"playbackBtnClicked");    if (m_lPlaybackID == -1)    {        if(m_lUserID == -1)        {            NSLog(@"Please login on the device first!");            return;        }                m_lPlaybackID = NET_DVR_PlayBackByName(m_lUserID, "ch0001_00000000333000100", NULL);        if (m_lPlaybackID == -1)        {            NSLog(@"NET_DVR_PlayBackByName failed:%d",  NET_DVR_GetLastError());            UIAlertView *alert = [[UIAlertView alloc]                                  initWithTitle:kWarningTitle                                  message:kRealPlayFailMsg                                  delegate:nil                                  cancelButtonTitle:kWarningConfirmButton                                  otherButtonTitles:nil];            [alert show];            [alert release];                        [self stopPlayback];            return;        }                if (!NET_DVR_SetPlayDataCallBack_V40(m_lPlaybackID, fPlayDataCallBack_V40 , self))        {            NSLog(@"NET_DVR_SetPlayDataCallBack_V40 failed:%d",  NET_DVR_GetLastError());            [self stopPlayback];            return;        }                if (!NET_DVR_PlayBackControl_V40(m_lPlaybackID, NET_DVR_PLAYSTART, NULL, 0, NULL, NULL))        {            NSLog(@"NET_DVR_PlayBackControl_V40 failed:%d",  NET_DVR_GetLastError());            [self stopPlayback];            return;        }        m_bStopPlayback = false;        [m_playbackButton setTitle:@"Stop Playback" forState:UIControlStateNormal];    }    else    {        m_bStopPlayback = true;        [self stopPlayback];        [m_playbackButton setTitle:@"Start Playback" forState:UIControlStateNormal];    }}*/- (bool) loginNormalDevice{    //  Get value    NSString * iP = m_deviceIpField.text;    NSString * port = m_devicePortField.text;    NSString * usrName = m_uerNameField.text;    NSString * password = m_passwordField.text;        DeviceInfo *deviceInfo = [[DeviceInfo alloc] init];    deviceInfo.chDeviceAddr = iP;    deviceInfo.nDevicePort = [port integerValue];    deviceInfo.chLoginName = usrName;    deviceInfo.chPassWord = password;        // device login    NET_DVR_DEVICEINFO_V30 logindeviceInfo = {0};        // encode type    NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);    m_lUserID = NET_DVR_Login_V30((char*)[deviceInfo.chDeviceAddr UTF8String],                                  deviceInfo.nDevicePort,                                  (char*)[deviceInfo.chLoginName cStringUsingEncoding:enc],                                  (char*)[deviceInfo.chPassWord UTF8String],                                  &logindeviceInfo);        printf("iP:%s\n", (char*)[deviceInfo.chDeviceAddr UTF8String]);    printf("Port:%d\n", deviceInfo.nDevicePort);    printf("UsrName:%s\n", (char*)[deviceInfo.chLoginName cStringUsingEncoding:enc]);    printf("Password:%s\n", (char*)[deviceInfo.chPassWord UTF8String]);        // login on failed    if (m_lUserID == -1)    {        UIAlertView *alert = [[UIAlertView alloc]                              initWithTitle:kWarningTitle                              message:kLoginDeviceFailMsg                              delegate:nil                              cancelButtonTitle:kWarningConfirmButton                              otherButtonTitles:nil];        [alert show];        [alert release];        return false;    }        if(logindeviceInfo.byChanNum > 0)    {        g_iStartChan = logindeviceInfo.byStartChan;        g_iPreviewChanNum = logindeviceInfo.byChanNum;    }    else if(logindeviceInfo.byIPChanNum > 0)    {        g_iStartChan = logindeviceInfo.byStartDChan;        g_iPreviewChanNum = logindeviceInfo.byIPChanNum + logindeviceInfo.byHighDChanNum * 256;    }        return true;}- (bool) loginEZVIZDevice{    NET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO struLoginInfo = {0};    NET_DVR_DEVICEINFO_V30 struDeviceInfo = {0};    //    sprintf(struLoginInfo.sEzvizServerAddress, "pbdev.ys7.com");//    struLoginInfo.wPort = 443;//    sprintf(struLoginInfo.sAccessToken, "at.2xv1wfuz4rrymc9h6nxyoxlu8o3wqgr5-1os2z4snl0-0ayy1vi-l9nluxmum");//    sprintf(struLoginInfo.sAppID, "com.hik.visualintercom");//    sprintf(struLoginInfo.sFeatureCode, "226f102a99ad0e078504d380b9ddf760");//    sprintf(struLoginInfo.sUrl, "/api/device/transmission");//    sprintf(struLoginInfo.sDeviceID, "520247131");//    sprintf(struLoginInfo.sClientType, "0");//    sprintf(struLoginInfo.sOsVersion, "5.0.1");//    sprintf(struLoginInfo.sNetType, "UNKNOWN");//    sprintf(struLoginInfo.sSdkVersion, "v.5.1.5.30");    sprintf(struLoginInfo.sEzvizServerAddress, "pbdev.ys7.com");    struLoginInfo.wPort = 443;    sprintf(struLoginInfo.sAccessToken, "at.2xv1wfuz4rrymc9h6nxyoxlu8o3wqgr5-1os2z4snl0-0ayy1vi-l9nluxmum");    sprintf(struLoginInfo.sAppID, "com.hik.visualintercom");    sprintf(struLoginInfo.sFeatureCode, "226f102a99ad0e078504d380b9ddf760");    sprintf(struLoginInfo.sUrl, "/api/device/transmission");    sprintf(struLoginInfo.sDeviceID, "520247131");    sprintf(struLoginInfo.sClientType, "0");    sprintf(struLoginInfo.sOsVersion, "5.0.1");    sprintf(struLoginInfo.sNetType, "UNKNOWN");    sprintf(struLoginInfo.sSdkVersion, "v.5.1.5.30");    m_lUserID = NET_DVR_CreateOpenEzvizUser(&struLoginInfo, &struDeviceInfo);    NSLog(@"0000000000000 NET_DVR_CreateEzvizUser[%d] with[%d]", m_lUserID, NET_DVR_GetLastError());            // login on failed    if (m_lUserID == -1)    {        DWORD dwRet = -1;        dwRet = NET_DVR_GetLastError();        UIAlertView *alert = [[UIAlertView alloc]                                initWithTitle:kWarningTitle                                message:kLoginDeviceFailMsg                                delegate:nil                                cancelButtonTitle:kWarningConfirmButton                                otherButtonTitles:nil];        [alert show];        [alert release];        return false;    }    return true;}// login button click-(IBAction) loginBtnClicked:(id)sender{    NSLog(@"loginBtnClicked");        if (m_lUserID == -1)    {        // init        BOOL bRet = NET_DVR_Init();        if (!bRet)        {            NSLog(@"NET_DVR_Init failed");        }        NET_DVR_SetExceptionCallBack_V30(0, NULL, g_fExceptionCallBack, NULL);        NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];        const char* pDir = [documentPath UTF8String];        NET_DVR_SetLogToFile(3, (char*)pDir, true);                if([self loginNormalDevice])//        if([self loginEZVIZDevice])        {            [m_loginButton setTitle:@"Logout" forState:UIControlStateNormal];        }    }    else     {        NET_DVR_Logout(m_lUserID);//        NET_DVR_DeleteOpenEzvizUser(m_lUserID);        NET_DVR_Cleanup();        m_lUserID = -1;        [m_loginButton setTitle:@"Login" forState:UIControlStateNormal];    }	}//stop preview-(void) stopPlay{	if (m_lRealPlayID != -1)	{		NET_DVR_StopRealPlay(m_lRealPlayID);		m_lRealPlayID = -1;			}	       if(m_nPreviewPort >= 0)       {           if(!PlayM4_StopSound())           {               NSLog(@"PlayM4_StopSound failed");           }           if (!PlayM4_Stop(m_nPreviewPort))           {               NSLog(@"PlayM4_Stop failed");           }           if(!PlayM4_CloseStream(m_nPreviewPort))           {               NSLog(@"PlayM4_CloseStream failed");           }           if (!PlayM4_FreePort(m_nPreviewPort))           {               NSLog(@"PlayM4_FreePort failed");           }             m_nPreviewPort = -1;       }}//stop playback- (void) stopPlayback{    if (m_lPlaybackID != -1)    {            NET_DVR_StopPlayBack(m_lPlaybackID);            m_lPlaybackID = -1;    }        if(m_nPlaybackPort >= 0)    {        if (!PlayM4_Stop(m_nPlaybackPort))         {            NSLog(@"PlayM4_Stop failed");        }        if(!PlayM4_CloseStream(m_nPlaybackPort))        {            NSLog(@"PlayM4_CloseStream failed");        }        if (!PlayM4_FreePort(m_nPlaybackPort))        {            NSLog(@"PlayM4_FreePort failed");        }        m_nPlaybackPort = -1;    }    }// Implement viewDidLoad to do additional setup after loading the view, typically from a nib.- (void)viewDidLoad {	m_lUserID = -1;	m_lRealPlayID = -1;    m_lPlaybackID = -1;    m_nPreviewPort = -1;    m_nPlaybackPort = -1;    m_bRecord = false;    m_bPTZL = false;    //    m_deviceIpField.text = @"27.13.190.148";//    m_devicePortField.text = @"8000";//    m_uerNameField.text = @"admin";//    m_passwordField.text = @"hskj8888";    //    m_deviceIpField.text = @"192.168.31.119";//    m_devicePortField.text = @"8001";//    m_uerNameField.text = @"admin";//    m_passwordField.text = @"admin123";//        m_deviceIpField.text = @"27.153.212.254";    m_devicePortField.text = @"8002";    m_uerNameField.text = @"admin";    m_passwordField.text = @"admin123";	    int nWidth = m_playView.frame.size.width / 2;    int nHeight = m_playView.frame.size.height / 2;    for(int i = 0; i < MAX_VIEW_NUM; i++)    {        m_multiView[i] = [[UIView alloc] initWithFrame:CGRectMake((i%(MAX_VIEW_NUM/2)) * nWidth, (i/(MAX_VIEW_NUM/2)) * nHeight, nWidth - 1, nHeight - 1)];        m_multiView[i].backgroundColor = [UIColor clearColor];        [m_playView addSubview:m_multiView[i]];    }        	// hide keybord	[[NSNotificationCenter defaultCenter] addObserver:self                                                          											 selector:@selector(keyboardWillHide:)                                                                  												 name:UIKeyboardWillHideNotification											   object:nil];    g_pController = self;    	[super viewDidLoad];}/*// Override to allow orientations other than the default portrait orientation.- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation {    // Return YES for supported orientations    return (interfaceOrientation == UIInterfaceOrientationPortrait);}*/- (void)didReceiveMemoryWarning {	// Releases the view if it doesn't have a superview.    [super didReceiveMemoryWarning];		// Release any cached data, images, etc that aren't in use.}- (void)viewDidUnload {	if (m_lRealPlayID != -1)	{		NET_DVR_StopRealPlay(m_lRealPlayID);		m_lRealPlayID = -1;	}           if(m_lPlaybackID != -1)       {           NET_DVR_StopPlayBack(m_lPlaybackID);           m_lPlaybackID = -1;       }           if(m_lUserID != -1)       {           NET_DVR_Logout(m_lUserID);           NET_DVR_Cleanup();           m_lUserID = -1;       }    [super viewDidLoad];}#pragma mark -#pragma mark textField UITextField Delegate methods/******************************************************************************* Function:			textFieldEditingDidBegin Description:		enter edit box,hide picture,controller up Input:				sender － button down Output:			 Return:			 *******************************************************************************/- (IBAction) textFieldEditingDidBegin:(id)sender{	[UIView beginAnimations:@"login.animation" context:nil];		[UIView commitAnimations];	}/******************************************************************************* Function:			textFieldEditingDidEndOnExit Description:		exit edit box,hide picture,controller focus change Input:				sender － button down Output:			 Return:			 *******************************************************************************/- (IBAction) textFieldEditingDidEndOnExit:(id)sender{	// foucs on username edit box,click done,focus on password edit box	if (sender == m_deviceIpField)	{		[m_devicePortField becomeFirstResponder];	}		else if (sender == m_devicePortField)	{		[m_uerNameField becomeFirstResponder];	}		else if (sender == m_uerNameField)	{		[m_passwordField becomeFirstResponder];	}		// if focus on password edit box,click done,revert GUI	else if (sender == m_passwordField)	{		[UIView beginAnimations:@"login.animation" context:nil];	}	else 	{		// do nothing	}}/******************************************************************************* Function:			keyboardWillHide Description:		exit edit box,hide picture,controller focus change Input:				note － keyboard hide Output:			 Return:			 *******************************************************************************/- (IBAction)keyboardWillHide:(NSNotification *)note{	[UIView beginAnimations:@"login.animation" context:nil];	[UIView commitAnimations];}// hide copy and paste button- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{	[UIMenuController sharedMenuController].menuVisible = NO;		return YES;}- (void)dealloc {	if (m_playView != nil)	{		[m_playView release];		m_playView = nil;	}		if (m_playThreadID != nil)	{		[m_playThreadID release];		m_playThreadID = nil;	}	    [super dealloc];}@end